<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project3</title>
    <script th:src="@{main.js}" src="main.js"></script>
    <script th:src="@{sound.js}" src="sound.js"></script>
    <script th:src="@{stages.js}" src="stages.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #222;
        }

        canvas {
            border: 2px solid #444;
            background: #333;
            /*block-size: 50%;*/
        }
    </style>

</head>
<body>
<canvas id="instCanvas"></canvas>
<script>
    // Инициализация canvas
    const canvas = document.getElementById('instCanvas');
    const baseWidth = 1200;
    const baseHeight = 1000;
    const ctx = canvas.getContext('2d');
    const GRID_SIZE = 60
    const game_debug = false
    const inst = {
        stage: 1,
        time: {},
        fps: 0,
        player: {},
        walls: [],
        ladders: [],
        boxes: [],
        buttons: [],
        gates: [],
        target: {},
        keys: {},
        eventKey: {},
        audio: []
    }

    const background = new Image();
    const inventoryBox = new Image();
    const inventoryBarrel = new Image();
    const inventoryLadder = new Image();
    inventoryBox.src = 'src/obj/box.png'
    inventoryBarrel.src = 'src/obj/barrel.png'
    inventoryLadder.src = `src/obj/ladder/1.png`
    background.src = 'src/cover.png'
    // background.onload = function background() {
    //     const scale = Math.min(canvas.width / background.width, canvas.height / background.height);
    //     const width = background.width * scale;
    //     const height = background.height * scale;
    //     ctx.drawImage(background, (canvas.width - width) / 2, (canvas.height - height) / 2, width, height);
    // }


    function preview() {
        clearInterval(inst.time)
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        inst.player = null
        inst.target = null
        inst.boxes = []
        inst.walls = []
        inst.ladders = []
        inst.buttons = []
        inst.gates = []
        inst.inventory = new Map()
        inst.inventory.set('box', 0)
        inst.inventory.set('barrel', 0)
        inst.inventory.set('ladder', 0)
        stages.get(inst.stage)();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#02850c';
        ctx.font = '40px Calibri';
        ctx.fillText(`Уровень ${inst.stage}`, 100, 300);
        ctx.fillStyle = '#caccc1';
        if (inst.stage === 1) {
            ctx.font = '30px Calibri';
            ctx.fillText("Помоги коту заполучить заветную монетку ", 200, 400);
        } else {
            ctx.font = '50px Calibri';
            ctx.fillText("Супер!", 400, 400);
        }
        ctx.font = '30px Calibri';
        ctx.fillStyle = '#69d1e3';
        ctx.fillText(`Для начала уровня заново жми 'Enter'`, 100, 650);
        ctx.fillText(`Переключение уровней: клавиша 'Z'- назад, клавиша 'X' - вперед`, 100, 700);
    }

    function initial() {
        preview()
        try {
            inst.audio.get('back').play()
        } catch (e) {
        }
        inst.time = setInterval(() => {
            main()
        }, 8)
    }


    function main(timestamp) {
        // Очистка canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!game_debug) {
            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
        }
        // Расчет FPS
        if (inst.lastTime) {
            inst.fps = Math.round(1000 / (timestamp - inst.lastTime));
        }


        //------ Основное перемещение -------------
        inst.player.gravity = !inst.player.collision(inst.player.x, inst.player.y, [...inst.ladders])
            && !inst.player.collision(inst.player.x, inst.player.y + GRID_SIZE, [...inst.walls, ...inst.boxes, ...inst.ladders])
        if (inst.player.gravity) {
            inst.player.targetY = inst.player.y + GRID_SIZE;
            inst.player.isFalling = true;
            inst.player.isMoving = true;
        }
        inst.player.move()
        for (const box of inst.boxes) {
            box.checkState()
            box.gravity = !box.collision(box.x, box.y + GRID_SIZE, [...inst.walls, ...inst.boxes, ...inst.ladders, inst.player])
            if (box.gravity) {
                box.targetY = box.y + GRID_SIZE;
                box.isFalling = true;
                box.isMoving = true;
            }
            box.move()
        }
        //------ /Кнопки - Ворота-------------
        for (const button of inst.buttons) {
            button.checkState()
            button.active = inst.boxes.some(box => box.collision(box.targetX, box.targetY, [button])) ||
                inst.player.collision(inst.player.targetX, inst.player.targetY, [button])
        }
        for (const gate of inst.gates) {
            gate.checkState()
            if (!gate.open && !inst.walls.includes(gate)) {
                inst.walls.push(gate)
            }
            if (gate.open && inst.walls.includes(gate)) {
                inst.walls = inst.walls.filter(wall => !wall.open)
            }
        }
        //------ Кнопки - Ворота/ -------------

        // inst.buttons.forEach(e => console.log(e.type + "|" + e.active))
        // inst.gates.forEach(e => console.log(e.type + "|" + e.open))
        //-------------------

        if (game_debug) {
            for (const obj of [...inst.walls, ...inst.ladders, ...inst.boxes, ...inst.buttons, inst.target, inst.player]) {
                ctx.fillStyle = obj.color;
                ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                ctx.fillText(`${obj.id}`, obj.x, obj.y);
            }
            //сетка
            for (let i = 0; i < canvas.width; i += GRID_SIZE) {
                for (let j = 0; j < canvas.height; j += GRID_SIZE) {
                    ctx.fillStyle = '#e1e1e0';
                    ctx.font = '12px Calibri';
                    ctx.fillText(`x:${i / GRID_SIZE} y:${j / GRID_SIZE}`, i + 3, j + 25);
                    ctx.strokeRect(i, j, GRID_SIZE, GRID_SIZE);
                }
            }
        } else {
            const drawObj = [inst.target, ...inst.walls, ...inst.boxes, ...inst.gates, ...inst.buttons]
                .sort((a, b) => a.targetX - b.targetX || b.targetY - a.targetY || b.zIndex - a.zIndex)
            // drawObj.forEach(i=>console.log(i.x))
            for (const obj of [...inst.ladders, ...drawObj]) {
                obj.draw()
            }
            inst.player.draw()
        }

        // Отрисовка информации
        ctx.fillStyle = '#fff';
        ctx.font = '25px Calibri';
        // ctx.fillText(`Steps: ${inst.player.steps}`, 10, 20);
        ctx.fillText(`Для начала уровня заново жми 'Enter'`, 10, 20);
        ctx.fillText(`Переключение уровней 'Z'- назад, 'X' - вперед`, 10, 40);
        ctx.fillStyle = '#2f3136';
        ctx.fillRect(baseWidth - (GRID_SIZE * 3) - 20, 0, GRID_SIZE * 4, GRID_SIZE * 1.5);
        ctx.fillStyle = '#fff';
        ctx.font = '15px Calibri';
        ctx.fillText(`Жми '3'`, GRID_SIZE * 19, GRID_SIZE * 0.3);
        ctx.fillText(`${inst.inventory.get('ladder')}`, GRID_SIZE * 19 + 14, GRID_SIZE * 1.4);
        ctx.drawImage(inventoryLadder, baseWidth - GRID_SIZE, 30, 40, 40)
        ctx.fillText(`Жми '2'`, GRID_SIZE * 18, GRID_SIZE * 0.3);
        ctx.fillText(`${inst.inventory.get('barrel')}`, GRID_SIZE * 18 + 14, GRID_SIZE * 1.4);
        ctx.drawImage(inventoryBarrel, baseWidth - GRID_SIZE * 2, 30, 40, 40)
        ctx.fillText(`Жми '1'`, GRID_SIZE * 17, GRID_SIZE * 0.3);
        ctx.fillText(`${inst.inventory.get('box')}`, GRID_SIZE * 17 + 14, GRID_SIZE * 1.4);
        ctx.drawImage(inventoryBox, baseWidth - GRID_SIZE * 3, 30, 40, 40)
        inst.lastTime = timestamp;
        //Проверка прохождения
        if (inst.player.x === inst.target.x && inst.player.y === inst.target.y) {
            inst.stage++
            preview()
        }
    }

    // Обработчики клавиатуры
    onkeydown = (e) => {
        e.preventDefault();
        handlePlayerInput(e.key);
    };

    onkeyup = (e) => {
        e.preventDefault();
        inst.eventKey = 'stop'
    };

    const handlePlayerInput = (key) => {
        if (key === 'Enter') {
            initial();
        }
        if (key === 'z') {
            if (inst.stage > 1) inst.stage--;
            preview();
        }
        if (key === 'x') {
            if (inst.stage < 9) inst.stage++;
            preview();
        }

        // Если игрок уже движется
        if (inst.player.isMoving || inst.player.gravity) {
            return;
        }
        // Создание объектов из инвентаря
        if (key === '1' || key === '2' || key === '3') {
            const obj = key === '1' ? 'box' : key === '2' ? 'barrel' : 'ladder'
            let count = inst.inventory.get(obj)
            if (inst.inventory.get(obj) !== 0) {
                if (key === '1' || key === '2') {
                    inst.boxes.push(key === '1'
                        ? new Box(inst.player.x / GRID_SIZE, inst.player.y / GRID_SIZE, 1, 1, 'rgba(183,113,28,1)')
                        : new Barrel(inst.player.x / GRID_SIZE, inst.player.y / GRID_SIZE, 1, 1, 'rgba(183,113,28,1)')
                    )
                } else if (key === '3') {
                    inst.ladders.push(new Ladder(inst.player.x / GRID_SIZE, inst.player.y / GRID_SIZE, 1, 1, 'rgba(183,113,28,1)'))
                }
                inst.inventory.set(obj, --count)
                inst.audio.get('newObj').play();
            }
        }
        inst.eventKey = key;
        inst.keys = key;

        let targetY = key === 'ArrowDown' ? inst.player.y + GRID_SIZE : inst.player.y - GRID_SIZE;
        let targetX = key === 'ArrowRight' ? inst.player.x + GRID_SIZE : inst.player.x - GRID_SIZE;

        // Логика движения по лестнице
        inst.player.onLadder = inst.player.collision(inst.player.x, inst.player.y, [...inst.ladders]) ||
            (key === 'ArrowDown' && inst.player.collision(inst.player.x, inst.player.y + GRID_SIZE, [...inst.ladders]));

        if (inst.player.onLadder && !inst.player.isMoving && !inst.player.collision(inst.player.x, targetY, [...inst.walls]) && ['ArrowUp', 'ArrowDown'].includes(key)) {
            inst.player.isPush = false;
            inst.player.targetY = targetY;
            inst.player.isMoving = true;

            // Логика горизонтального движения
        } else if (['ArrowLeft', 'ArrowRight'].includes(key)) {
            let isCollisionBox = false;
            inst.audio.get('step').play();

            if (!inst.player.isMoving && !inst.player.collision(targetX, inst.player.y, [...inst.walls])) {
                for (const box of [...inst.boxes]) {
                    if (!box.isMoving && !box.gravity && inst.player.collision(targetX, inst.player.y, [box])) {
                        const dirX = box.x - inst.player.x > 1 ? GRID_SIZE : -GRID_SIZE;
                        const boxTargetX = box.x + dirX;
                        inst.player.isPush = true;
                        isCollisionBox = true;
                        if (!box.collision(boxTargetX, box.y, [...inst.boxes, ...inst.walls])) {
                            box.targetX = boxTargetX;
                            box.direction = dirX;
                            box.isMoving = true;
                            inst.player.targetX = targetX;
                            inst.player.isMoving = true;
                        }
                    }
                }
                if (!isCollisionBox) {
                    inst.player.isPush = false;
                    inst.player.targetX = targetX;
                    inst.player.isMoving = true;
                }
            }
        }
    };

    initSound()
    preview()

    // Функция для адаптации размера канваса
    function resizeCanvas() {
        const container = canvas.parentElement;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        const scale = Math.min(containerWidth / baseWidth, containerHeight / baseHeight);

        canvas.width = baseWidth;
        canvas.height = baseHeight;

        canvas.style.width = `${baseWidth * scale}px`;
        canvas.style.height = `${baseHeight * scale}px`;
        preview()
    }

    window.addEventListener('load', resizeCanvas);
    window.addEventListener('resize', resizeCanvas);

</script>
</body>