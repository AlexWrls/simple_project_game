<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project3</title>
    <script th:src="@{main.js}" src="main.js"></script>
    <script th:src="@{preview.js}" src="preview.js"></script>
    <script th:src="@{sound.js}" src="sound.js"></script>
    <script th:src="@{stages.js}" src="stages.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #222;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        #canvas {
            border: 2px solid #444;
            background: #333;
            display: none;
            /*block-size: 50%;*/
        }
    </style>

</head>
<body>
<div class="loader" id="loader"></div>
<canvas id="instCanvas"></canvas>
<script>
    // Инициализация canvas
    const canvas = document.getElementById('instCanvas');
    const baseWidth = 1200;
    const baseHeight = 1000;
    const ctx = canvas.getContext('2d');
    const GRID_SIZE = 60
    const game_debug = false
    const inst = {
        stage: 1,
        stageDescription: '',
        time: {},
        fps: 0,
        player: {},
        walls: [],
        ladders: [],
        boxes: [],
        buttons: [],
        gates: [],
        portals: [],
        guns: [],
        objects: [],
        target: {},
        keys: {},
        eventKey: {},
        audio: []
    }

    const GAME_OBJ = Object.freeze({
        BOX: 'src/obj/game_object/box_obj.png',
        BARREL: 'src/obj/game_object/barrel_obj.png',
        LADDER: 'LADDER',
        GUN: 'src/obj/game_object/gun_obj.png',
        GOLD: 'src/obj/target1.png',
    })

    const background = new Image();
    background.src = 'src/cover.png'

    const cat = new Image();
    cat.src = 'src/player/cat-stand.png'
    // background.onload = function background() {
    //     const scale = Math.min(canvas.width / background.width, canvas.height / background.height);
    //     const width = background.width * scale;
    //     const height = background.height * scale;
    //     ctx.drawImage(background, (canvas.width - width) / 2, (canvas.height - height) / 2, width, height);
    // }


    function preview(step) {
        document.getElementById('loader').style.display = 'block';
        inst.audio.get(SOUND.BACKGROUND).pauseSound()
        clearInterval(inst.time)
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        inst.player = null
        inst.target = null
        inst.boxes = []
        inst.walls = []
        inst.ladders = []
        inst.buttons = []
        inst.gates = []
        inst.portals = []
        inst.guns = []
        inst.objects = []
        inst.inventory = new Inventory(0, 0, 0, 0)
        stages.get(inst.stage)();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#02850c';
        ctx.font = '40px Calibri';
        ctx.fillText(`Уровень ${inst.stage}`, 100, 300);
        ctx.fillStyle = '#caccc1';
        ctx.font = '30px Calibri';
        // ctx.fillText(`== ${inst.stageDescription} ==`, 400 - (inst.stageDescription.length*3), 400);
        ctx.font = '30px Calibri';
        ctx.fillStyle = '#69d1e3';
        ctx.fillText(`Для начала уровня жми 'Enter' или 'Space'`, 100, 650);
        ctx.fillText(`Переключение уровней: клавиша 'Z'- назад, клавиша 'X' - вперед`, 100, 700);
        ctx.drawImage(cat, 350, 500, 92, 110)
        drawSpeechBubble(ctx, 150, 350, 800, 110, 250, 500, inst.stageDescription);
        if (step !== undefined) {
            ctx.fillText(`Уровень ${inst.stage - 1} пройден за ${step} шагов`, 100, 100);
        }
        document.getElementById('instCanvas').style.display = 'block';
        document.getElementById('loader').style.display = 'none';
    }

    function initial() {
        preview()
        inst.audio.get(SOUND.BACKGROUND).setLoop(true)
        inst.audio.get(SOUND.BACKGROUND).playSound()
        inst.audio.get(SOUND.STEP).setLoop(true)
        inst.time = setInterval(() => {
            main()
        }, 8)
    }


    function main(timestamp) {
        // Очистка canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!game_debug) {
            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
        }
        // Расчет FPS
        if (inst.lastTime) {
            inst.fps = Math.round(1000 / (timestamp - inst.lastTime));
        }


        //------ Основное перемещение -------------
        inst.player.gravity = !inst.player.collision(inst.player.x, inst.player.y, [...inst.ladders])
            && !inst.player.collision(inst.player.x, inst.player.y + GRID_SIZE, [...inst.walls, ...inst.boxes, ...inst.ladders])
        if (inst.player.gravity) {
            inst.player.targetY = inst.player.y + GRID_SIZE;
            inst.player.isFalling = true;
            inst.player.isMoving = true;
        }
        inst.player.move()
        for (const box of inst.boxes) {
            box.checkState()
            box.gravity = !box.collision(box.x, box.y + GRID_SIZE, [...inst.walls, ...inst.boxes, ...inst.ladders, inst.player])
            if (box.gravity) {
                box.targetY = box.y + GRID_SIZE;
                box.isFalling = true;
                box.isMoving = true;
            }
            box.move()
        }
        //------ /Кнопки - Ворота-------------
        for (const button of inst.buttons) {
            button.checkState()
            button.active = inst.boxes.some(box => box.collision(box.targetX, box.targetY, [button])) ||
                inst.player.collision(inst.player.targetX, inst.player.targetY, [button])
        }
        for (const gate of inst.gates) {
            gate.checkState()
            if (!gate.open && !inst.walls.includes(gate)) {
                inst.walls.push(gate)
            }
            if (gate.open && inst.walls.includes(gate)) {
                inst.walls = inst.walls.filter(wall => !wall.open)
            }
        }
        //------ /Выстрелы -------------
        for (const gun of [...inst.guns]) {
            gun.checkState()
            gun.move()
        }
        //------ /Объекты -------------
        for (const obj of [...inst.objects]) {
            if (inst.player.collision(inst.player.x, inst.player.y, [obj])) {
                inst.inventory.addObject(obj.imgStandSrc)
                inst.objects = inst.objects.filter(i => i.id !== obj.id)
            }
        }
        //------ Порталы/ -------------
        for (const portal of [...inst.portals]) {
            const outPortal = portal.getAnotherPortal();
            if (!inst.player.isMoving && portal.collision(portal.x, portal.y, [inst.player])) {
                inst.audio.get(SOUND.PORTAL).playSound()
                const dirX = inst.player.direction === 'ArrowLeft' ? -GRID_SIZE : GRID_SIZE;
                if (!handlePlayerMove(outPortal.x, outPortal.y, outPortal.x + dirX)) {
                    inst.player.x = portal.x;
                    inst.player.targetX = portal.x - dirX;
                    inst.player.y = inst.player.targetY = portal.y;
                    inst.player.isPush = false;
                    inst.player.isMoving = true;
                }
            }
            for (const obj of [...inst.boxes]) {
                const dirX = obj.x - inst.player.targetX > 1 ? GRID_SIZE : -GRID_SIZE;
                if (!obj.isMoving && portal.collision(portal.x, portal.y, [obj])) {
                    inst.audio.get(SOUND.PORTAL).playSound()
                    const objX = obj.x
                    const objY = obj.y
                    obj.x = outPortal.x
                    obj.targetX = outPortal.x + dirX
                    obj.y = obj.targetY = outPortal.y;
                    if (obj.collision(obj.targetX, obj.y, [...inst.boxes])) {
                        obj.direction = 0
                        obj.x = objX
                        obj.targetX = portal.x - dirX
                        obj.y = obj.targetY = objY
                        if (obj.collision(obj.targetX, obj.y, [inst.player])) {
                            inst.player.targetX = inst.player.targetX - dirX;
                            inst.player.isPush = false;
                            inst.player.isMoving = true;
                        }
                    }
                }
            }
            for (const obj of [...inst.guns]) {
                const dirX = obj.x - inst.player.targetX > 1 ? GRID_SIZE : -GRID_SIZE;
                if (portal.collision(portal.x, portal.y, [obj])) {
                    inst.audio.get(SOUND.PORTAL).playSound()
                    obj.x = outPortal.x + dirX
                    obj.targetX = outPortal.x + dirX
                    obj.y = obj.targetY = outPortal.y;
                }
            }
        }

        //------ Кнопки - Ворота/ -------------

        // inst.buttons.forEach(e => console.log(e.type + "|" + e.active))
        // inst.gates.forEach(e => console.log(e.type + "|" + e.open))
        //-------------------

        if (game_debug) {
            for (const obj of [...inst.guns, ...inst.portals, ...inst.walls, ...inst.ladders, ...inst.boxes, ...inst.buttons, inst.target, ...inst.objects, inst.player]) {
                ctx.fillStyle = obj.color;
                ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                ctx.fillText(`${obj.id}`, obj.x, obj.y);
            }
            //сетка
            for (let i = 0; i < canvas.width; i += GRID_SIZE) {
                for (let j = 0; j < canvas.height; j += GRID_SIZE) {
                    ctx.fillStyle = '#e1e1e0';
                    ctx.font = '12px Calibri';
                    ctx.fillText(`x:${i / GRID_SIZE} y:${j / GRID_SIZE}`, i + 3, j + 25);
                    ctx.strokeRect(i, j, GRID_SIZE, GRID_SIZE);
                }
            }
        } else {
            const drawObj = [...inst.portals, inst.target, ...inst.walls, ...inst.boxes, ...inst.gates, ...inst.buttons]
                .sort((a, b) => a.targetX - b.targetX || b.targetY - a.targetY || b.zIndex - a.zIndex)
            // drawObj.forEach(i=>console.log(i.x))
            for (const obj of [...inst.ladders, ...drawObj, ...inst.objects, ...inst.guns]) {
                obj.draw()
            }
            inst.player.draw()
        }

        // Отрисовка информации
        ctx.fillStyle = '#fff';
        ctx.font = '20px "Comic Sans MS", cursive, sans-serif';
        ctx.fillText(`Для начала уровня заново жми 'Enter'`, 10, baseHeight - 20);
        ctx.fillText(`Переключение уровней 'Z'- назад, 'X' - вперед`, 10,baseHeight - 40);
        ctx.fillText(`Отключение музыки  'M'- mute sound`, 10, baseHeight -60);
        ctx.font = '24px "Comic Sans MS", cursive, sans-serif';
        ctx.fillText(`Шаги: ${Math.round(inst.player.steps / GRID_SIZE)}`, baseWidth - GRID_SIZE *2, baseHeight - GRID_SIZE/2 );
        inst.inventory.draw()
        inst.lastTime = timestamp;
        //Проверка прохождения
        if (inst.player.x === inst.target.x && inst.player.y === inst.target.y) {
            inst.audio.get(SOUND.STEP).setLoop(false)
            inst.audio.get(SOUND.NEW_LEVEL).playSound()
            inst.stage++
            preview(Math.round(inst.player.steps / GRID_SIZE))
        }
    }

    // Обработчики клавиатуры
    onkeydown = (e) => {
        e.preventDefault();
        handlePlayerInput(e.key);
    };

    onkeyup = (e) => {
        e.preventDefault();
        inst.eventKey = 'stop'
    };

    const handlePlayerInput = (key) => {
        if (key === 'Enter' || key === ' ') {
            initial();
        }
        if (key === 'z' || key === 'я') {
            if (inst.stage > 1) inst.stage--;
            preview();
        }
        if (key === 'x' || key === 'ч') {
            if (inst.stage < 12) inst.stage++;
            preview();
        }
        if (key === 'm' || key === 'ь') {
            inst.audio.get(SOUND.BACKGROUND).muteSound();
        }

        // Если игрок уже движется
        if (inst.player.isMoving || inst.player.gravity) {
            return;
        }
        inst.inventory.handleCreate(key)
        inst.eventKey = key;
        inst.keys = key;

        let targetY = key === 'ArrowDown' ? inst.player.y + GRID_SIZE : inst.player.y - GRID_SIZE;
        let targetX = key === 'ArrowRight' ? inst.player.x + GRID_SIZE : inst.player.x - GRID_SIZE;

        // Логика движения по лестнице
        inst.player.onLadder = inst.player.collision(inst.player.x, inst.player.y, [...inst.ladders]) ||
            (key === 'ArrowDown' && inst.player.collision(inst.player.x, inst.player.y + GRID_SIZE, [...inst.ladders]));

        if (inst.player.onLadder && !inst.player.isMoving && !inst.player.collision(inst.player.x, targetY, [...inst.walls]) && ['ArrowUp', 'ArrowDown'].includes(key)) {
            inst.player.isPush = false;
            inst.player.targetY = targetY;
            inst.player.isMoving = true;

            // Логика горизонтального движения
        } else if (['ArrowLeft', 'ArrowRight'].includes(key)) {
            handlePlayerMove(inst.player.x, inst.player.y, targetX)
        }
    };

    //Проверяет перемещение игрока, устанавливает координаты в случае успеха
    // return true - перемещение возможно / false - иначе
    function handlePlayerMove(x, y, targetX) {
        console.log("x=" + x + "   targetX=" + targetX)
        inst.player.x = x
        inst.player.y = y
        let isCollisionBox = false;
        inst.audio.get(SOUND.STEP).playSound();

        if (!inst.player.isMoving && !inst.player.collision(targetX, inst.player.y, [...inst.walls])) {
            for (const box of [...inst.boxes]) {
                if (!box.isMoving && !box.gravity && inst.player.collision(targetX, inst.player.y, [box])) {
                    console.log(inst.player.direction)
                    const dirX = inst.player.x - targetX > 0 ? -GRID_SIZE : GRID_SIZE;
                    const boxTargetX = box.x + dirX;
                    inst.player.isPush = true;
                    isCollisionBox = true;
                    if (!box.collision(boxTargetX, box.y, [...inst.boxes, ...inst.walls])) {
                        box.targetX = boxTargetX;
                        box.direction = dirX;
                        box.isMoving = true;
                        inst.player.targetX = targetX;
                        inst.player.targetY = y;
                        inst.player.isMoving = true;
                        return true
                    }
                }
            }
            if (!isCollisionBox) {
                inst.player.isPush = false;
                inst.player.targetX = targetX;
                inst.player.targetY = y;
                inst.player.isMoving = true;
                return true
            }
        }
        return false
    }

    initSound()
    preview()

    // Функция для адаптации размера канваса
    function resizeCanvas() {
        const container = canvas.parentElement;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        const scale = Math.min(containerWidth / baseWidth, containerHeight / baseHeight);

        canvas.width = baseWidth;
        canvas.height = baseHeight;

        canvas.style.width = `${baseWidth * scale}px`;
        canvas.style.height = `${baseHeight * scale}px`;
        preview()
    }

    window.addEventListener('load', resizeCanvas);
    window.addEventListener('resize', resizeCanvas);

</script>
</body>