<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project3</title>
    <script th:src="@{main.js}" src="main.js"></script>
    <script th:src="@{sound.js}" src="sound.js"></script>
    <script th:src="@{stages.js}" src="stages.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: grid;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #222;
        }

        .controls {
            justify-content: right;
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }
        .controls-stage {
            justify-content: left;
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .control-button {
            padding: 0.75rem 1.5rem;
            background-color: #4a5568;
            color: #e2e8f0;
            font-weight: bold;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }

        .control-button:hover {
            background-color: #6a778c;
        }

        .control-button:active {
            transform: scale(0.98);
        }

        .game-container {
            width: 98vw;
            height: 80vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        canvas {
            border: 4px solid #4a5568;
            display: block;
            background: #333;
            max-width: 100%;
            max-height: 100%;
        }

    </style>

</head>
<body>
<div class="game-container">
    <canvas id="instCanvas"></canvas>
</div>
<span class="controls-stage">
    <button id="enter_button" class="control-button">Enter</button>
    <button id="z_button"  class="control-button">next</button>
    <button id="x_button"  class="control-button">prev</button>
</span>
    <span class="controls">
    <button id="up_button" class="control-button">Вверх</button>
    <button id="down_button" class="control-button">Вниз</button>
    <button id="left_button" class="control-button">Влево</button>
    <button id="right_button" class="control-button">Вправо</button>
</span>

<script>

    // Инициализация canvas
    const canvas = document.getElementById('instCanvas');
    const baseWidth = 1000;
    const baseHeight = 800;
    const ctx = canvas.getContext('2d');
    const GRID_SIZE = 60
    const game_debug = false
    const inst = {
        stage: 1,
        time: {},
        fps: 0,
        player: {},
        walls: [],
        ladders: [],
        boxes: [],
        buttons: [],
        gates: [],
        target: {},
        keys: {},
        eventKey: {},
        audio: []
    }

    const background = new Image();
    background.src = 'src/cover.png'
    // background.onload = function background() {
    //     const scale = Math.min(canvas.width / background.width, canvas.height / background.height);
    //     const width = background.width * scale;
    //     const height = background.height * scale;
    //     ctx.drawImage(background, (canvas.width - width) / 2, (canvas.height - height) / 2, width, height);
    // }


    function preview() {
        clearInterval(inst.time)
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        inst.player = null
        inst.target = null
        inst.boxes = []
        inst.walls = []
        inst.ladders = []
        inst.buttons = []
        inst.gates = []
        stages.get(inst.stage)();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#02850c';
        ctx.font = '40px Calibri';
        ctx.fillText(`Уровень ${inst.stage}`, 100, 300);
        ctx.fillStyle = '#caccc1';
        if (inst.stage === 1) {
            ctx.font = '30px Calibri';
            ctx.fillText("Помоги коту заполучить заветную монетку ", 200, 400);
        } else {
            ctx.font = '50px Calibri';
            ctx.fillText("Супер!", 400, 400);
        }
        ctx.font = '30px Calibri';
        ctx.fillStyle = '#69d1e3';
        ctx.fillText(`Для начала уровня заново жми 'Enter'`, 100, 650);
        ctx.fillText(`Переключение уровней: клавиша 'Z'- назад, клавиша 'X' - вперед`, 100, 700);
    }

    function initial() {
        preview()
        try {
            inst.audio.get('back').play()
        } catch (e){}
        inst.time = setInterval(() => {
            main()
        }, 8)
    }


    function main(timestamp) {
        // Очистка canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!game_debug) {
            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
        }
        // Расчет FPS
        if (inst.lastTime) {
            inst.fps = Math.round(1000 / (timestamp - inst.lastTime));
        }


        //------ Основное перемещение -------------
        inst.player.gravity = !inst.player.collision(inst.player.x, inst.player.y, [...inst.ladders])
            && !inst.player.collision(inst.player.x, inst.player.y + GRID_SIZE, [...inst.walls, ...inst.boxes, ...inst.ladders])
        if (inst.player.gravity) {
            inst.player.targetY = inst.player.y + GRID_SIZE;
            inst.player.isFalling = true;
            inst.player.isMoving = true;
        }
        inst.player.move()
        for (const box of inst.boxes) {
            box.checkState()
            box.gravity = !box.collision(box.x, box.y + GRID_SIZE, [...inst.walls, ...inst.boxes, ...inst.ladders, inst.player])
            if (box.gravity) {
                box.targetY = box.y + GRID_SIZE;
                box.isFalling = true;
                box.isMoving = true;
            }
            box.move()
        }
        //------ /Кнопки - Ворота-------------
        for (const button of inst.buttons) {
            button.checkState()
            button.active = inst.boxes.some(box => box.collision(box.targetX, box.targetY, [button])) ||
                inst.player.collision(inst.player.targetX, inst.player.targetY, [button])
        }
        for (const gate of inst.gates) {
            gate.checkState()
            if (!gate.open && !inst.walls.includes(gate)) {
                inst.walls.push(gate)
            }
            if (gate.open && inst.walls.includes(gate)) {
                inst.walls = inst.walls.filter(wall => !wall.open)
            }
        }
        //------ Кнопки - Ворота/ -------------

        // inst.buttons.forEach(e => console.log(e.type + "|" + e.active))
        // inst.gates.forEach(e => console.log(e.type + "|" + e.open))
        //-------------------

        if (game_debug) {
            for (const obj of [...inst.walls, ...inst.ladders, ...inst.boxes, ...inst.buttons, inst.target, inst.player]) {
                ctx.fillStyle = obj.color;
                ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                ctx.fillText(`${obj.id}`, obj.x, obj.y);
            }
            //сетка
            for (let i = 0; i < canvas.width; i += GRID_SIZE) {
                for (let j = 0; j < canvas.height; j += GRID_SIZE) {
                    ctx.fillStyle = '#e1e1e0';
                    ctx.font = '12px Calibri';
                    ctx.fillText(`x:${i / GRID_SIZE} y:${j / GRID_SIZE}`, i + 3, j + 25);
                    ctx.strokeRect(i, j, GRID_SIZE, GRID_SIZE);
                }
            }
        } else {
            const drawObj = [inst.target, ...inst.walls, ...inst.boxes, ...inst.gates, ...inst.buttons]
                .sort((a, b) => a.targetX - b.targetX || b.targetY - a.targetY || b.zIndex - a.zIndex)
            // drawObj.forEach(i=>console.log(i.x))
            for (const obj of [...inst.ladders, ...drawObj]) {
                obj.draw()
            }
            inst.player.draw()
        }

        // Отрисовка информации
        ctx.fillStyle = '#fff';
        ctx.font = '25px Calibri';
        // ctx.fillText(`Steps: ${inst.player.steps}`, 10, 20);
        ctx.fillText(`Для начала уровня заново жми 'Enter'`, 10, 20);
        ctx.fillText(`Переключение уровней 'Z'- назад, 'X' - вперед`, 10, 40);

        inst.lastTime = timestamp;
        //Проверка прохождения
        if (inst.player.x === inst.target.x && inst.player.y === inst.target.y) {
            inst.stage++
            preview()
        }
    }

    // Обработчики клавиатуры
    onkeydown = (e) => { e.preventDefault(); handlePlayerInput(e.key);};
    onkeyup = (e) => { e.preventDefault();inst.eventKey = 'stop' };

    // Обработчики кнопок
    document.getElementById('up_button').addEventListener('touchstart', (e) => {e.preventDefault(); handlePlayerInput('ArrowUp');});
    document.getElementById('up_button').addEventListener('touchend', () =>  inst.eventKey = 'stop');

    document.getElementById('down_button').addEventListener('touchstart', (e) => { e.preventDefault(); handlePlayerInput('ArrowDown');});
    document.getElementById('down_button').addEventListener('touchend', () =>  inst.eventKey = 'stop');

    document.getElementById('left_button').addEventListener('touchstart', (e) => {e.preventDefault(); handlePlayerInput('ArrowLeft');});
    document.getElementById('left_button').addEventListener('touchend', () =>  inst.eventKey = 'stop');

    document.getElementById('right_button').addEventListener('touchstart', (e) => {e.preventDefault();handlePlayerInput('ArrowRight');});
    document.getElementById('right_button').addEventListener('touchend', () =>  inst.eventKey = 'stop');
    // Кнопки для "Enter","Z","X"
    document.getElementById('enter_button').addEventListener('touchstart', () => {handlePlayerInput('Enter');});
    document.getElementById('z_button').addEventListener('touchstart', (e) => { e.preventDefault();handlePlayerInput('z'); });
    document.getElementById('x_button').addEventListener('touchstart', (e) => {e.preventDefault(); handlePlayerInput('x'); });

    const handlePlayerInput = (key) => {
        if (key === 'Enter') {
            initial();
        }
        if (key === 'z') {
            if (inst.stage > 1) inst.stage--;
            preview();
        }
        if (key === 'x') {
            if (inst.stage < 8) inst.stage++;
            preview();
        }

        // Если игрок уже движется
        if (inst.player.isMoving || inst.player.gravity) {
            return;
        }

        inst.eventKey = key;
        inst.keys = key;

        let targetY = key === 'ArrowDown' ? inst.player.y + GRID_SIZE : inst.player.y - GRID_SIZE;
        let targetX = key === 'ArrowRight' ? inst.player.x + GRID_SIZE : inst.player.x - GRID_SIZE;

        // Логика движения по лестнице
        inst.player.onLadder = inst.player.collision(inst.player.x, inst.player.y, [...inst.ladders]) ||
            (key === 'ArrowDown' && inst.player.collision(inst.player.x, inst.player.y + GRID_SIZE, [...inst.ladders]));

        if (inst.player.onLadder && !inst.player.isMoving && !inst.player.collision(inst.player.x, targetY, [...inst.walls]) && ['ArrowUp', 'ArrowDown'].includes(key)) {
            inst.player.isPush = false;
            inst.player.targetY = targetY;
            inst.player.isMoving = true;

            // Логика горизонтального движения
        } else if (['ArrowLeft', 'ArrowRight'].includes(key)) {
            let isCollisionBox = false;
            inst.audio.get('step').play();

            if (!inst.player.isMoving && !inst.player.collision(targetX, inst.player.y, [...inst.walls])) {
                for (const box of [...inst.boxes]) {
                    if (!box.isMoving && !box.gravity && inst.player.collision(targetX, inst.player.y, [box])) {
                        const dirX = box.x - inst.player.x > 1 ? GRID_SIZE : -GRID_SIZE;
                        const boxTargetX = box.x + dirX;
                        inst.player.isPush = true;
                        isCollisionBox = true;
                        if (!box.collision(boxTargetX, box.y, [...inst.boxes, ...inst.walls])) {
                            box.targetX = boxTargetX;
                            box.direction = dirX;
                            box.isMoving = true;
                            inst.player.targetX = targetX;
                            inst.player.isMoving = true;
                        }
                    }
                }
                if (!isCollisionBox) {
                    inst.player.isPush = false;
                    inst.player.targetX = targetX;
                    inst.player.isMoving = true;
                }
            }
        }
    };

    initSound()
    preview()

    // Функция для адаптации размера канваса
    function resizeCanvas() {
        const container = canvas.parentElement;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        const scale = Math.min(containerWidth / baseWidth, containerHeight / baseHeight);

        canvas.width = baseWidth;
        canvas.height = baseHeight;

        canvas.style.width = `${baseWidth * scale*0.8}px`;
        canvas.style.height =  `${baseHeight * scale*0.8}px`;
        preview()
    }
    window.addEventListener('load', resizeCanvas);
    window.addEventListener('resize', resizeCanvas);

</script>
</body>